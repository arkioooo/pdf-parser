from dotenv import load_dotenv
import os
import fitz
import pandas as pd
import numpy as np
import re
from fuzzywuzzy import process

load_dotenv()
poppler_bin = os.getenv('poppler_bin')

if poppler_bin is None:
    raise ValueError("Environment variable poppler_bin is not set!")

def extract_all_tables(pdf_path):
    """Extract all text from PDF using PyMuPDF"""
    doc = fitz.open(pdf_path)
    full_text = ""
    for page_num in range(len(doc)):
        page = doc.load_page(page_num)
        full_text += page.get_text() + "\n"
    doc.close()
    return full_text

def form_table(raw_text):
    date_pat   = re.compile(r'^\d{2}/\d{2}/\d{2}$')
    amt_pat    = re.compile(r'^[\d,]+\.\d{2}$')
    ref_pat    = re.compile(r'^[A-Z0-9]{10,}$')

    skip = ('STATEMENT SUMMARY', 'Opening Balance', 'Dr Count', 'Cr Count',
            'Generated On', 'Generated By', 'Page No', 'HDFC BANK',
            'Contents of this statement', 'Registered Office')
    lines = [ln.strip() for ln in raw_text.split('\n')
             if ln.strip() and not any(tok in ln for tok in skip)]
    rows, cur = [], None

    for ln in lines:
        if date_pat.fullmatch(ln):
            if cur:
                rows.append(cur)
            cur = {
                'Date'            : ln,
                'Narration'       : '',
                'Chq./Ref.No.'    : '',
                'Value Dt'        : '',
                'Withdrawal Amt.' : '',
                'Deposit Amt.'    : '',
                'Closing Balance' : ''
            }
            continue

        if cur is None:
            continue

        if amt_pat.fullmatch(ln):
            if not cur['Withdrawal Amt.'] and not cur['Deposit Amt.']:
                if any(k in cur['Narration'].upper() for k in
                       (' NEFT CR', ' RTGS CR', ' CHQ DEP', 'CR-', ' CREDIT', ' IMPS CR')):
                    cur['Deposit Amt.'] = ln
                else:
                    cur['Withdrawal Amt.'] = ln
            else:
                cur['Closing Balance'] = ln

        elif ref_pat.fullmatch(ln):
            cur['Chq./Ref.No.'] += (' ' if cur['Chq./Ref.No.'] else '') + ln

        elif date_pat.search(ln):
            cur['Value Dt'] = date_pat.search(ln).group()

        else:
            cur['Narration'] += (' ' if cur['Narration'] else '') + ln

    if cur:
        rows.append(cur)

    return pd.DataFrame(rows)

def clean_repeated_headers(df):
    """Remove header rows and summary sections"""
    if df.empty:
        return df
    
    # Remove rows where any column contains header-like text
    header_patterns = [
        r'date', r'narration', r'chq.*ref.*no', r'value.*dt',
        r'withdrawal.*amt', r'deposit.*amt', r'closing.*balance',
        r'opening.*balance', r'statement.*summary'
    ]
    
    mask = pd.Series([True] * len(df))
    
    for i, row in df.iterrows():
        for col in df.columns:
            cell_value = str(row[col]).lower().strip()
            for pattern in header_patterns:
                if re.search(pattern, cell_value):
                    mask[i] = False
                    break
            if not mask[i]:
                break
    
    # Also remove rows where date column doesn't contain valid date
    date_pattern = r'\d{2}/\d{2}/\d{2}'
    for i, row in df.iterrows():
        if mask[i] and not re.match(date_pattern, str(row['Date']).strip()):
            mask[i] = False
    
    df_clean = df[mask].copy()
    df_clean = df_clean.dropna(how='all').reset_index(drop=True)
    
    return df_clean

def standardize(df):
    """Standardize column names and format"""
    if df.empty:
        return df
        
    # Keep original column names as they match our target format
    df = df.loc[:, ~df.columns.duplicated()]
    
    # Rename to match expected format
    column_mapping = {
        'Date': 'date',
        'Narration': 'narration', 
        'Chq./Ref.No.': 'chq_ref_no',
        'Value Dt': 'value_dt',
        'Withdrawal Amt.': 'withdrawal',
        'Deposit Amt.': 'deposit',
        'Closing Balance': 'closing_balance'
    }
    
    df = df.rename(columns=column_mapping)
    
    # Ensure all expected columns exist
    expected_cols = ['date', 'narration', 'withdrawal', 'deposit', 'closing_balance']
    for col in expected_cols:
        if col not in df.columns:
            df[col] = ''
    
    return df[expected_cols]

def calculate_metrics(df):
    """Calculate financial metrics from DataFrame"""
    if df.empty:
        return 0, 0, 0, 0
    
    total_credit = 0
    total_debit = 0
    opening_bal = 0
    closing_bal = 0
    
    # Calculate total withdrawals (debits)
    if 'withdrawal' in df.columns:
        for val in df['withdrawal']:
            if val and str(val).strip():
                clean_val = str(val).replace(',', '').strip()
                try:
                    total_debit += float(clean_val)
                except ValueError:
                    continue
    
    # Calculate total deposits (credits)  
    if 'deposit' in df.columns:
        for val in df['deposit']:
            if val and str(val).strip():
                clean_val = str(val).replace(',', '').strip()
                try:
                    total_credit += float(clean_val)
                except ValueError:
                    continue
    
    # Get opening and closing balances
    if 'closing_balance' in df.columns:
        balance_values = []
        for val in df['closing_balance']:
            if val and str(val).strip():
                clean_val = str(val).replace(',', '').strip()
                try:
                    balance_values.append(float(clean_val))
                except ValueError:
                    continue
        
        if balance_values:
            closing_bal = balance_values[-1]
            first_balance = balance_values[0]
            
            # Calculate opening balance (approximate)
            first_withdrawal = 0
            first_deposit = 0
            
            if df['withdrawal'].iloc[0]:
                try:
                    first_withdrawal = float(str(df['withdrawal'].iloc[0]).replace(',', ''))
                except:
                    pass
                    
            if df['deposit'].iloc[0]:
                try:
                    first_deposit = float(str(df['deposit'].iloc[0]).replace(',', ''))
                except:
                    pass
            
            opening_bal = first_balance + first_withdrawal - first_deposit
    
    return total_credit, total_debit, opening_bal, closing_bal

def run(pdf_path, poppler_bin):
    """Main function to process PDF and return transaction data"""
    raw_text = extract_all_tables(pdf_path)
    if len(raw_text) == 0:
        return None, (0, 0, 0, 0)
    
    txn_df = form_table(raw_text)
    if txn_df.empty:
        return None, (0, 0, 0, 0)
        
    txn_df = clean_repeated_headers(txn_df)
    std_df = standardize(txn_df)
    total_credit, total_debit, opening_bal, closing_bal = calculate_metrics(std_df)
    
    return std_df, (total_credit, total_debit, opening_bal, closing_bal)
